# JavaScript Patterns

![JavaScript.patterns](./Figure/cover/front-cover.jpg)

**“JavaScript patterns”中译本** - 《JavaScript 模式》

- 作者：[Stoyan Stefanov](http://www.phpied.com/)
- 翻译：[拔赤](http://jayli.github.com/)、[goddyzhao](http://goddyzhao.me)、[TooBug](http://www.toobug.net)

本书从 JavaScript 的实际使用场景出发，提炼了不少有价值的前端实用模式。模式的探索、创新，将永远是程序员自我提升的一条修炼之道，值得一读。

# 目录

## [第一章 绪言](./chapter1.markdown)

- 模式
- JavaScript：概念
	- 面向对象
	- 没有类
	- 原型
	- 运行环境
- ECMAScript 5
- JSLint
- 控制台工具

## [第二章 概要](./chapter2.markdown)

- 编写可维护的代码
- 减少全局对象
	- 全局变量的问题
	- 忘记var时的副作用
	- 访问全局对象
	- 单var模式
	- 声明提前：分散的var带来的问题
- for循环
- for-in循环
- （不）扩充内置原型
- switch模式
- 避免隐式类型转换
	- 避免使用eval()
- 使用parseInt()进行数字转换
- 代码规范
	- 缩进
	- 花括号
	- 左花括号的放置
	- 空格
- 命名规范
	- 构造函数命名中的大小写
	- 单词分隔
	- 其他命名风格
- 写注释
- 写API文档
	- 示例：YUIDoc
- 编写易读的代码
- 同事评审（Peer Reviews）
- 发布时的代码压缩（Minify）
- 运行JSLint
- 小结

## [第三章 字面量和构造函数](./chapter3.markdown)

- 对象字面量
	- 对象字面量语法
	- 通过构造函数创建对象
	- Object()构造函数的参数
- 自定义构造函数
	- 构造函数的返回值
- 强制使用new的模式
	- 命名规范
	- 使用that
	- 调用自身的构造函数
- 数组字面量
	- 数组字面量语法
	- Array()构造函数的“陷阱”
	- 检查是否数组
- JSON
	- 使用JSON
- 正则表达式字面量
	- 正则表达式字面量语法
- 原始值的包装对象
- 错误处理对象
- 小结

## [第四章 函数](./chapter4.markdown)

- 背景知识
	- 术语
	- 声明 vs 表达式：命名与提前
	- 函数的name属性
	- 声明提前
- 回调模式
	- 回调的例子
	- 回调和作用域
	- 异步事件监听
	- 延时
	- 类库中的回调
- 返回函数
- 重定义函数
- 即时函数
	- 即时函数的参数
	- 即时函数的返回值
	- 好处和用法
- 对象即时初始化
- 条件初始化
- 函数属性——记忆模式（Memoization）
- 配置对象
- 柯里化 （Curry）
	- 函数应用
	- 部分应用
	- 柯里化（Currying）
	- 什么时候使用柯里化
- 小结

## [第五章 对象创建模式](./chapter5.markdown)

- 命名空间模式
	- 通用命名空间函数
- 依赖声明
- 私有属性和方法
	- 私有成员
	- 特权方法
	- 私有化成员失效
	- 对象字面量和私有成员
	- 原型和私有成员
	- 将私有函数暴露为共有方法
- 模块模式
	- 暴露模块模式
	- 创建构造函数的模块
	- 在模块中引入全局上下文
- 沙箱模式
	- 全局构造函数
	- 添加模块
	- 实现构造函数
- 静态成员
	- 公有静态成员
	- 私有静态成员
- 对象常量
- 链式调用模式
	- 链式调用模式的利弊
- method()方法
- 小结

## [第六章 代码复用模式](./chapter6.markdown)

- 类式继承 vs 现代继承模式
- 类式继承的期望结果
- 类式继承1——默认模式
	- 跟踪原型链
	- 这种模式的缺点
- 类式继承2——借用构造函数
	- 原型链
	- 利用借用构造函数模式实现多继承
	- 借用构造函数的利与弊
- 类式继承3——借用并设置原型
- 类式继承4——共享原型
- 类式继承5——临时构造函数
	- 存储父类（Superclass）
	- 重置构造函数引用
- Klass
- 原型继承
	- 讨论
	- ECMAScript5中的原型继承
- 通过复制属性继承
- 混元（Mix-ins）
- 借用方法
	- 例：从数组借用
	- 借用并绑定
	- Function.prototype.bind()
- 小结

## [第七章 设计模式](./chapter7.markdown)

- 单例
	- 使用new
	- 将实例放到静态属性中
	- 将实例放到闭包中
- 工厂模式
	- 内置对象工厂
- 遍历模式
- 装饰模式
	- 用法
	- 实现
	- 使用列表实现
- 策略模式
	- 数据验证示例
- 外观模式
- 代理模式
	- 一个例子
	- 使用代理对象做缓存
- 中介者模式
	- 中介者示例
- 观察者模式
	- 例1：杂志订阅
	- 例2：按键游戏
- 小结

## [第八章 DOM和浏览器模式](./chapter8.markdown)

- 分离
- DOM编程
	- DOM访问
	- DOM操作
- 事件
	- 事件处理
	- 事件委托
- 长时间运行的脚本
	- setTimeout()
	- Web Workers
- 远程脚本编程
	- XMLHttpRequest
	- JSONP
	- 框架（frame）和图片信标(image beacon)
- 部署JavaScript
	- 合并脚本
	- 代码压缩
	- 缓存头
	- 使用CDN
- 加载策略
	- script元素的位置
	- HTTP分块
	- 动态script元素实现非阻塞下载
	- 延迟加载
	- 按需加载
	- 预加载JavaScript
- 小结
